<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ú–∏—Å—Ç–∏—á–µ—Å–∫–∏–π –û–∫–∫—É–ª—å—Ç–∏–∑–º - –ü—Ä–æ—Ä–æ—á–µ—Å—Ç–≤–æ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
            font-family: 'Georgia', serif;
            position: relative;
        }
        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        /* –û–≤–µ—Ä–ª–µ–π –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        /* –°–≤–µ—á–∏ —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º –º–µ—Ä—Ü–∞–Ω–∏—è */
        .candles {
            display: flex;
            gap: 20px;
            opacity: 0;
            animation: fadeIn 3s forwards 0.5s;
        }
        .candles span {
            font-size: 3rem;
            animation: candleFlicker 2s infinite;
        }
        /* –¢–∞–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø–∏—Å—å–º–µ–Ω–∞ */
        .mystic-text {
            color: #fff;
            font-size: 1.5rem;
            margin: 20px;
            opacity: 0;
            animation: fadeIn 3s forwards 2s;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
        }
        /* –û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç */
        .overlay h1 {
            color: #fff;
            font-size: 3rem;
            margin: 20px;
            opacity: 0;
            animation: fadeIn 3s forwards 1s;
            text-shadow: 0 0 15px rgba(255,255,255,0.8);
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        @keyframes candleFlicker {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
<canvas id="glCanvas"></canvas>
<div class="overlay">
    <div class="candles">
        <span>üïØÔ∏è</span>
        <span>üïØÔ∏è</span>
        <span>üïØÔ∏è</span>
    </div>
    <div class="mystic-text">·õâ ·ö† ·ö¢ ·õû ·õó ·ö± ·ö®</div>
    <h1>–¢—ã –≥–æ—Ç–æ–≤ —É—Å–ª—ã—à–∞—Ç—å –ø—Ä–∞–≤–¥—É?</h1>
</div>


<script>

    const canvas = document.getElementById("glCanvas");
    const gl = canvas.getContext("webgl");
    if (!gl) {
        alert("WebGL –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è!");
    }

    // –í–µ—Ä—à–∏–Ω–Ω—ã–π —à–µ–π–¥–µ—Ä ‚Äì —Ä–∏—Å—É–µ—Ç –¥–≤–∞ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –Ω–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω
    const vertexShaderSource = `
      attribute vec2 position;
      void main() {
          gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    // –§—Ä–∞–≥–º–µ–Ω—Ç–Ω—ã–π —à–µ–π–¥–µ—Ä, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ –≤–∞—à–µ–º –∫–æ–¥–µ:
    const fragmentShaderSource = `
      precision highp float;
      uniform vec2 iResolution;
      uniform float iTime;

      mat2 rotate2D(float r) {
          return mat2(cos(r), sin(r), -sin(r), cos(r));
      }

      // based on the follow tweet:
      // https://twitter.com/zozuar/status/1621229990267310081
      void mainImage( out vec4 fragColor, in vec2 fragCoord )
      {
          // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–∏–∫—Å–µ–ª–µ–π (–æ—Ç 0 –¥–æ 1)
          vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
          vec3 col = vec3(0.0);
          float t = iTime;

          vec2 n = vec2(0.0);
          vec2 q = vec2(0.0);
          vec2 p = uv;
          float d = dot(p, p);
          float S = 12.0;
          float a = 0.0;
          mat2 m = rotate2D(5.0);

          for (float j = 0.0; j < 20.0; j++) {
              p *= m;
              n *= m;
              q = p * S + t * 4.0 + sin(t * 4.0 - d * 6.0) * 0.8 + j + n; // wtf???
              a += dot(cos(q)/S, vec2(0.2));
              n -= sin(q);
              S *= 1.2;
          }

          col = vec3(4.0, 2.0, 1.0) * (a + 0.2) + a + a - d;
          fragColor = vec4(col, 1.0);
      }

      void main() {
          mainImage(gl_FragColor, gl_FragCoord.xy);
      }
    `;

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error("–û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ —à–µ–π–¥–µ—Ä–∞:", gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("–û—à–∏–±–∫–∞ –ª–∏–Ω–∫–æ–≤–∫–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã:", gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([
            -1, -1,
            1, -1,
            -1,  1,
            -1,  1,
            1, -1,
            1,  1,
        ]),
        gl.STATIC_DRAW
    );

    const positionLocation = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    const iResolutionLocation = gl.getUniformLocation(program, "iResolution");
    const iTimeLocation = gl.getUniformLocation(program, "iTime");

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function render(time) {
        gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
        gl.uniform1f(iTimeLocation, time * 0.001);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
</script>
</body>
</html>
